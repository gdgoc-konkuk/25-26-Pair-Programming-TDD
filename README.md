프로그래밍 교육 전문가입니다. 요청하신 대로, 수많은 프로그래머를 교육하기 위한 '미션' 문서를 작성했습니다. 이 미션은 제공된 영상(코틀린으로 만드는 TDD Bowling Kata)을 '모범 답안'이자 '마스터 클래스'로 활용합니다.

---

### 1. 미션 개요

미션 명: TDD 볼링 카타(Kata)

훈련 목표: 테스트 주도 개발(TDD)의 리듬을 체화하고, '작동하는 깔끔한 코드(Clean Code That Works)'를 작성하는 능력을 배양합니다.

여러분은 오늘 프로그래밍 장인이 되기 위한 '카타(Kata)' 훈련을 시작합니다. 카타는 무술가가 동일한 동작을 반복 수련하여 완벽한 자세를 몸에 익히는 것처럼, 프로그래머가 의도적인 연습을 통해 모범적인 패턴을 체득하는 훈련법입니다.

본 미션은 로버트 C. 마틴(Uncle Bob)이 고안한 고전적인 TDD 학습용 '볼링 게임 카타'를 수행하는 것입니다 [[00:00](http://www.youtube.com/watch?v=8JLILHs0_yk&t=0)]. TDD는 단순히 테스트를 먼저 작성하는 것이 아닙니다. 이는 실패한 테스트, 성공, 그리고 리팩토링이라는 짧은 주기를 반복하며 [[01:08](http://www.youtube.com/watch?v=8JLILHs0_yk&t=68)], 테스트가 가능한 설계를 점진적으로 발전시키는 강력한 기술입니다 [[00:24](http://www.youtube.com/watch?v=8JLILHs0_yk&t=24)].

### 2. 학습 목표

이 미션을 완료하면 다음을 얻을 수 있습니다.

- **TDD의 3원칙(실패 -> 통과 -> 리팩토링)의 리듬**을 실제 코드로 경험합니다.
- 가장 단순한 경우부터 시작하여 복잡한 로직으로 점진적으로 나아가는 **'Baby Steps' 전략**을 체득합니다 [[00:47](http://www.youtube.com/watch?v=8JLILHs0_yk&t=47)].
- 새로운 요구사항(스페어, 스트라이크)이 추가될 때, **기존 코드를 자신 있게 리팩토링**하는 과정을 경험합니다 [[28:44](http://www.youtube.com/watch?v=8JLILHs0_yk&t=1724)].

### 3. 미션 브리핑: 볼링 게임 규칙

점수 계산 로직을 구현해야 합니다. 볼링 게임의 규칙은 다음과 같습니다.

- 게임은 총 **10개의 프레임**으로 구성됩니다.
- 각 프레임에서 플레이어는 기본적으로 **2번**의 공을 굴립니다.
- **스페어(Spare):** 한 프레임의 두 번의 투구로 10개의 핀을 모두 쓰러뜨린 경우, 10점 + **다음 1회 투구**의 핀 개수를 보너스 점수로 받습니다.
- **스트라이크(Strike):** 한 프레임의 첫 투구로 10개의 핀을 모두 쓰러뜨린 경우, 해당 프레임은 즉시 종료되며 10점 + **다음 2회 투구**의 핀 개수를 보너스 점수로 받습니다.
- **10번째 프레임:**
    - 스페어를 기록하면 1번의 보너스 투구 기회를 얻습니다.
    - 스트라이크를 기록하면 2번의 보너스 투구 기회를 얻습니다.

### 4. 핵심 요구 사항 (API)

```kotlin
class Game {
    /**
     * 플레이어가 공을 굴려 쓰러뜨린 핀의 개수를 기록합니다.
     * @param pins 쓰러뜨린 핀의 수 (0-10)
     */
    fun roll(pins: Int) {
        // ...
    }

    /**
     * 현재까지의 총 점수를 계산하여 반환합니다.
     * @return 총 점수
     */
    fun score(): Int {
        // ...
    }
}
```

### 5. 수행 가이드 (단계별 챌린지)

**중요 원칙:** 각 단계를 수행할 때마다 **반드시 실패하는 테스트를 먼저 작성**하고, **오직 그 테스트를 통과할 최소한의 코드**만 작성한 후, 리팩토링하십시오.

### 1단계: 'Gutter Game' (0점짜리 게임)

가장 간단한 시나리오입니다. 모든 공이 또랑으로 빠진 경우입니다.

- **Test:** 20번의 투구(`roll(0)`)를 수행한 후, `score()`가 0점을 반환하는지 확인하는 테스트를 작성하십시오 [[04:06](http://www.youtube.com/watch?v=8JLILHs0_yk&t=246)].
- **Do:** 이 테스트를 통과시키기 위한 *가장 최소한의* 코드를 작성합니다. (예: `score()`가 단순히 0을 반환하게 하드코딩) [[10:21](http://www.youtube.com/watch?v=8JLILHs0_yk&t=621)]

> [Pro-Tip]
> 
> 
> 영상에서처럼 [05:28], Game 클래스조차 만들기 전에 테스트 코드(val game = Game())를 먼저 작성하십시오. 컴파일 에러가 발생하는 것, 그것이 바로 TDD의 '첫 번째 실패'입니다.
> 

### 2단계: 'All Ones' (모두 1점)

- **Test:** 20번의 투구(`roll(1)`)를 수행한 후, `score()`가 20점을 반환하는지 확인하는 테스트를 작성하십시오 [[11:48](http://www.youtube.com/watch?v=8JLILHs0_yk&t=708)].
- **Do:** 1단계의 'Gutter Game' 테스트와 2단계의 'All Ones' 테스트를 *모두* 통과시키도록 코드를 수정합니다. (아마도 단순 합계 로직이 추가될 것입니다) [[19:18](http://www.youtube.com/watch?v=8JLILHs0_yk&t=1158)]

### 3단계: 'One Spare' (스페어 처리)

이제 복잡성이 추가됩니다.

- **Test:** 스페어 상황을 테스트합니다. (예: `roll(5)`, `roll(5)`, `roll(3)`, 이후 17번 `roll(0)`) [[25:34](http://www.youtube.com/watch?v=8JLILHs0_yk&t=1534)]
    - 점수는 `(5 + 5 + 3[보너스]) + 3 + 0... = 16` 점이 되어야 합니다 [[26:57](http://www.youtube.com/watch?v=8JLILHs0_yk&t=1617)].
- **Do:** 이 테스트를 통과시키십시오.
- **Refactor:** *아마도 이 시점에서 당신의 기존 설계(단순 합계)는 한계에 부딪힐 것입니다* [[27:51](http://www.youtube.com/watch?v=8JLILHs0_yk&t=1671)]. 스페어 보너스를 계산하려면 이전 롤들을 '기억'해야 합니다. 두 테스트(1, 2단계)를 깨뜨리지 않으면서, 3단계 테스트를 통과시키기 위해 **설계를 과감히 리팩토링**하십시오. (예: 롤 기록을 배열이나 리스트로 변경) [[29:46](http://www.youtube.com/watch?v=8JLILHs0_yk&t=1786)]

### 4단계: 'One Strike' (스트라이크 처리)

- **Test:** 스트라이크 상황을 테스트합니다. (예: `roll(10)`, `roll(3)`, `roll(4)`, 이후 16번 `roll(0)`) [[44:44](http://www.youtube.com/watch?v=8JLILHs0_yk&t=2684)]
    - 점수는 `(10 + 3[보너스] + 4[보너스]) + 3 + 4 + 0... = 24` 점이 되어야 합니다 [[46:06](http://www.youtube.com/watch?v=8JLILHs0_yk&t=2766)].
- **Do:** 스트라이크 보너스 로직을 구현합니다. 스트라이크는 한 프레임에 투구가 한 번이므로, 프레임 인덱스 관리가 스페어와 달라야 할 수 있습니다 [[48:23](http://www.youtube.com/watch?v=8JLILHs0_yk&t=2903)].

### 5단계: 'Perfect Game' (퍼펙트 게임)

최종 테스트입니다.

- **Test:** 12번의 스트라이크(`roll(10)`)를 수행한 후, `score()`가 300점을 반환하는지 확인하는 테스트를 작성하십시오 [[55:03](http://www.youtube.com/watch?v=8JLILHs0_yk&t=3303)].
- **Do:** 만약 4단계까지의 로직이 완벽했다면, 이 테스트는 **아무런 코드 수정 없이도 통과**해야 합니다 [[56:32](http://www.youtube.com/watch?v=8JLILHs0_yk&t=3392)]. 만약 실패한다면, 엣지 케이스를 처리하도록 로직을 수정하십시오.

---

### 6. 디브리핑 (영상 시청)

미션을 스스로 완료했거나, 도중에 막혔다면 이제 '마스터의 시연'을 볼 차례입니다.

**[영상 링크]** [코틀린으로 만드는 TDD Bowling Kata](http://www.youtube.com/watch?v=8JLILHs0_yk)

이 영상은 이 챌린지를 어떻게 우아하고 점진적으로 해결하는지 보여주는 모범 답안입니다. 영상을 시청하며 자신의 접근 방식과 다음 사항들을 비교해 보십시오.

- 관전 포인트 1: 리팩토링의 타이밍
    
    '스페어' 로직을 추가해야 할 때, 기존의 단순한 설계를 어떻게 과감히 변경하고 더 나은 설계로 나아가는지 확인하십시오 [27:51] -> [35:08].
    
- 관전 포인트 2: 코드의 가독성
    
    로직이 복잡해질 때, isSpare(), isStrike(), strikeBonus() [50:31], spareBonus() [52:47]와 같이 **함수를 추출(Extract Method)**하여 코드를 얼마나 읽기 쉽게 만드는지 주목하십시오.
    
- 관전 포인트 3: TDD의 흐름
    
    테스트 케이스를 선정하는 순서(가장 쉬운 것부터)와 실패한 테스트를 통과하기 위한 최소한의 노력(하드코딩 등)을 어떻게 활용하는지 관찰하십시오.
    

### 7. 최종 미션

영상을 통해 '마스터의 흐름'을 확인했다면, 이제 **자신의 코드를 모두 삭제**하십시오.

그리고 **처음부터 다시 이 카타를 수행**하십시오.

이 과정을 최소 3번 이상 반복하며, 영상에서 보여준 자연스러운 TDD의 흐름과 리팩토링 패턴을 자신의 것으로 만드십시오 [[57:41](http://www.youtube.com/watch?v=8JLILHs0_yk&t=3461)]. 그것이 이 '카타' 훈련의 진정한 목적입니다.

행운을 빕니다.